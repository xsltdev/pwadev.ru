{"extends":"/samples/base.json","order":3,"title":"Refs","description":"Interact with Web Component APIs via Refs.","section":"@lit/react","files":{"app.jsx":{"contentType":"text/typescript-jsx","content":"import React from 'https://esm.sh/react@18';\nimport {createRoot} from 'https://esm.sh/react-dom@18/client';\nimport {createComponent} from '@lit/react';\nimport {FlyingTriangles as FlyingTrianglesWC} from './flying-triangles.js';\n\n/*\n  The <flying-triangles> component is stateful and uncontrolled.\n\n  A stateful component maintains state independent of React.\n  Meaning component state must be reconciled with React state.\n  This is usually accomplished through refs and callbacks.\n  \n  <flying-triangles> will dispatch a 'playing-change' event when\n  component state changes.\n  \n  The 'playing-change' provides React an opportunity to update\n  UI data based on the properties and attributes of\n  a <flying-triangles> component.\n*/\n\nconst FlyingTriangles = createComponent({\n  react: React,\n  tagName: 'flying-triangles',\n  elementClass: FlyingTrianglesWC,\n  events: {onPlayingChange: 'playing-change'},\n});\n\nconst App = () => {\n  const ref = React.useRef(null);\n  const [isPlaying, setIsPlaying] = React.useState(false);\n\n  return (\n    <>\n      <FlyingTriangles\n        ref={ref}\n        onPlayingChange={() => {\n          setIsPlaying(!!ref.current?.isPlaying);\n        }}\n      />\n      <button disabled={isPlaying} onClick={() => ref.current?.play()}>\n        play\n      </button>\n      <button disabled={!isPlaying} onClick={() => ref.current?.pause()}>\n        pause\n      </button>\n    </>\n  );\n};\n\nconst root = createRoot(document.getElementById('app'));\n\nroot.render(<App />);\n"},"flying-triangles.js":{"content":"import {css, html, LitElement} from 'lit';\n\n/*\n  This file is for demo purposes only.\n\n  This module provides a web component that is stateful\n  and uncontrolled similar to video and audio elements.\n\n  The <flying-triangles> web component exposes the following API:\n    methods:\n      - play()\n      - pause()\n\n    properties:\n      - isPlaying\n\n    events:\n      - 'playing-change'\n*/\n\nconst styles = css`\n  :host {\n    max-width: 300px;\n    position: relative;\n    display: block;\n    cursor: pointer;\n  }\n\n  canvas {\n    border: 5px solid #343434;\n  }\n\n  p {\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    position: absolute;\n    opacity: 0.4;\n    margin: 0;\n  }\n`;\n\nexport class FlyingTriangles extends LitElement {\n  static properties = {\n    isPlaying: {state: true},\n  };\n  static styles = styles;\n\n  constructor() {\n    super();\n    this.isPlaying = false;\n  }\n\n  get canvas() {\n    return this.renderRoot?.querySelector('canvas') ?? null;\n  }\n\n  scene = createScene();\n  fps = 54;\n\n  render() {\n    return html`\n      <div @click=${this.onClick}>\n        <canvas height=\"300\" width=\"300\"></canvas>\n        <p>${this.isPlaying ? 'click to pause' : 'click to play'}</p>\n      </div>\n    `;\n  }\n\n  play() {\n    if (this.isPlaying) return;\n\n    this.isPlaying = true;\n    this.renderCanvas();\n    this.onPlayingChange();\n  }\n\n  pause() {\n    if (!this.isPlaying) return;\n\n    this.isPlaying = false;\n    cancelAnimationFrame(this.scene.rafId);\n    this.onPlayingChange();\n  }\n\n  onClick() {\n    this.isPlaying ? this.pause() : this.play();\n  }\n\n  onPlayingChange() {\n    this.dispatchEvent(new Event('playing-change', {composed: true}));\n  }\n\n  renderCanvas = () => {\n    this.scene.rafId = requestAnimationFrame(this.renderCanvas);\n    renderScene(this.canvas, this.scene, this.fps);\n  };\n}\ncustomElements.define('flying-triangles', FlyingTriangles);\n\nclass Wanderer {\n  // target bubble\n  bubbleRadius = 10 + Math.random() * 10;\n  bubbleDist = 50 + Math.random() * 15;\n  wedge = 0.1 + Math.random() * 0.2;\n  radians = Math.random() * Math.PI * 2;\n  target = {x: 0, y: 0};\n\n  // vehicle\n  mass = 5 + Math.random() * 5;\n  velocity = 2 + Math.random() * 3;\n  pos = {x: 0, y: 0};\n  theta = {x: 0, y: 0};\n  color = [\n    100 + Math.floor(Math.random() * 155),\n    100 + Math.floor(Math.random() * 155),\n    220,\n  ];\n}\n\nconst createScene = () => ({\n  deltaTime: 0,\n  timestamp: performance.now(),\n  integral: 20,\n  rafId: -1,\n  wanderers: [new Wanderer(), new Wanderer(), new Wanderer()],\n});\n\nconst renderScene = (canvas, state, fps) => {\n  // throttle renders\n  const now = performance.now();\n  const delta = now - state.timestamp;\n  const fpsAsMS = 1000 / fps;\n  if (delta < Math.max(fpsAsMS, state.integral)) {\n    return;\n  }\n\n  state.timestamp = now;\n  // throttle integration around 3 fps\n  state.deltaTime += Math.min(delta, 350);\n  // integrate timestep\n  while (state.deltaTime > state.integral) {\n    state.deltaTime -= state.integral;\n    // update scene objects\n    for (const wndr of state.wanderers) {\n      integrate(wndr);\n    }\n  }\n\n  // wrap characters inside the scene\n  for (const wndr of state.wanderers) {\n    wrapPos(canvas, wndr);\n  }\n\n  drawScene(canvas, state);\n};\n\nconst integrate = (wndr) => {\n  // increment chase bubble\n  wndr.radians += (Math.random() * 2 - 1) * wndr.wedge;\n  wndr.radians %= Math.PI * 2;\n\n  // build chase bubble target\n  wndr.target.x =\n    wndr.theta.x * wndr.bubbleDist + Math.cos(wndr.radians) * wndr.bubbleRadius;\n  wndr.target.y =\n    wndr.theta.y * wndr.bubbleDist + Math.sin(wndr.radians) * wndr.bubbleRadius;\n\n  // get orientation\n  normalize(wndr.target);\n  wndr.theta.x += wndr.target.x / wndr.mass;\n  wndr.theta.y += wndr.target.y / wndr.mass;\n  normalize(wndr.theta);\n\n  // add pos\n  wndr.pos.x += wndr.theta.x * wndr.velocity;\n  wndr.pos.y += wndr.theta.y * wndr.velocity;\n};\n\nconst normalize = (vec, mag = 1) => {\n  const sq = Math.sqrt(vec.x * vec.x + vec.y * vec.y);\n  vec.x = (vec.x / sq) * mag;\n  vec.y = (vec.y / sq) * mag;\n};\n\nconst wrapPos = (canvas, wndr) => {\n  wndr.pos.y = ((wndr.pos.y % canvas.height) + canvas.height) % canvas.height;\n  wndr.pos.x = ((wndr.pos.x % canvas.width) + canvas.width) % canvas.width;\n};\n\nconst drawScene = (canvas, state) => {\n  const ctx = canvas.getContext('2d');\n  if (ctx === null) return;\n\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.fillStyle = '#dedede';\n  ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n  for (const wndr of state.wanderers) {\n    ctx.save();\n\n    // translate canvas\n    ctx.translate(wndr.pos.x, wndr.pos.y);\n    ctx.rotate(Math.atan2(wndr.theta.x, wndr.theta.y) * -1);\n\n    // build the triangle\n    ctx.beginPath();\n    ctx.moveTo(-10, -10);\n    ctx.lineTo(0, 10);\n    ctx.lineTo(10, -10);\n    ctx.lineTo(0, -7);\n    ctx.closePath();\n\n    // paint the triangle\n    ctx.lineWidth = 10;\n    ctx.strokeStyle = '#343434';\n    ctx.stroke();\n    ctx.fillStyle = `rgb(${wndr.color[0]},${wndr.color[1]},${wndr.color[2]})`;\n    ctx.fill();\n\n    ctx.restore();\n  }\n};\n"},"react.d.js":{"content":"declare module 'https://esm.sh/react@18' {\n  export default React;\n}\n\ndeclare module 'https://esm.sh/react-dom@18/client' {\n  export * from 'react-dom/client';\n}","hidden":true},"index.html":{"content":"<!doctype html>\n<head>\n  <script type=\"module\" src=\"./app.js\"></script>\n</head>\n<body>\n  <div id=\"app\"></div>\n</body>\n"},"package.json":{"content":"{\n  \"dependencies\": {\n    \"lit\": \"^3\",\n    \"@lit/react\": \"^1\",\n    \"@types/react\": \"18.2.7\",\n    \"@types/react-dom\": \"^18\",\n    \"@types/react-dom/client\": \"^18\"\n  }\n}","hidden":true}}}