---
description: Добавьте шаблон к компоненту, чтобы определить, что он должен отображать. Шаблоны могут включать выражения, которые являются заполнителями для динамического контента
---

# Рендеринг

Добавьте шаблон к компоненту, чтобы определить, что он должен отображать. Шаблоны могут включать _выражения_, которые являются заполнителями для динамического контента.

Чтобы определить шаблон для компонента Lit, добавьте метод `render()`:

<litdev-example sandbox-base-url="https://playground.lit.dev/" style="--litdev-example-editor-lines-ts:11; --litdev-example-editor-lines-js:9; --litdev-example-preview-height:80px" project="v3-docs/templates/define" filename="my-element.ts"></litdev-example>

Запишите свой шаблон в HTML внутри JavaScript [tagged template literal](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Template_literals#tagged_templates) с помощью функции тегов Lit [`html`](https://lit.dev/docs/v3/api/templates/#html).

Шаблоны Lit могут включать в себя _выражения_ JavaScript. С помощью выражений можно задавать содержание текста, атрибуты, свойства и слушателей событий. Метод `render()` также может включать любой JavaScript — например, вы можете создавать локальные переменные для использования в выражениях.

## Рендерируемые значения { #renderable-values }

Обычно метод компонента `render()` возвращает один объект `TemplateResult` (тот же тип, который возвращается функцией тега `html`). Однако он может возвращать все, что Lit может отобразить в качестве дочернего элемента HTML:

-   Примитивные значения, такие как строка, число или булево.
-   Объекты `TemplateResult`, созданные функцией `html`.
-   Узлы DOM.
-   Значения sentinel [`nothing`](../templates/conditionals.md#conditionally-rendering-nothing) и [`noChange`](../templates/custom-directives.md#signaling-no-change).
-   Массивы или итерабели любого из поддерживаемых типов.

Это _почти_ идентично набору значений, которые могут быть приведены к дочернему выражению Lit [child expression](../templates/expressions.md#child-expressions). Единственное отличие заключается в том, что дочернее выражение может отображать `SVGTemplateResult`, возвращаемый функцией [`svg`](https://lit.dev/docs/v3/api/templates/#svg). Этот вид результата шаблона может быть отображен только как потомок элемента `<svg>`.

## Написание хорошего метода render()

Чтобы наилучшим образом использовать функциональную модель рендеринга Lit, ваш метод `render()` должен следовать следующим рекомендациям:

-   Избегайте изменения состояния компонента.
-   Избегайте возникновения побочных эффектов.
-   Используйте в качестве входных данных только свойства компонента.
-   Возвращать один и тот же результат при задании одних и тех же значений свойств.

Следование этим рекомендациям позволяет сохранить детерминированность шаблона и облегчает рассуждения о коде.

В большинстве случаев следует избегать обновления DOM за пределами `render()`. Вместо этого выражайте шаблон компонента как функцию его состояния и фиксируйте его состояние в свойствах.

Например, если вашему компоненту нужно обновлять пользовательский интерфейс при получении события, пусть слушатель события установит реактивное свойство, которое используется в `render()`, а не манипулирует DOM напрямую.

Дополнительную информацию см. в разделе [Реактивные свойства](properties.md).

## Составление шаблонов

Вы можете составлять шаблоны Lit из других шаблонов. В следующем примере шаблон компонента под названием `<my-page>` составляется из небольших шаблонов для верхнего и нижнего колонтитулов страницы и основного содержимого:

<litdev-example sandbox-base-url="https://playground.lit.dev/" style="--litdev-example-editor-lines-ts:34; --litdev-example-editor-lines-js:37; --litdev-example-preview-height:90px" project="v3-docs/templates/compose" filename="my-page.ts"></litdev-example>

В этом примере отдельные шаблоны определены как методы экземпляра, поэтому подкласс может расширить этот компонент и переопределить один или несколько шаблонов.

Вы также можете комбинировать шаблоны, импортируя другие элементы и используя их в своем шаблоне:

<litdev-example sandbox-base-url="https://playground.lit.dev/" style="--litdev-example-editor-lines-ts:18; --litdev-example-editor-lines-js:17; --litdev-example-preview-height:120px" project="v3-docs/templates/composeimports"></litdev-example>

## Когда отображаются шаблоны

При добавлении в DOM на странице компонент Lit первоначально отрисовывает свой шаблон. После первоначального рендеринга любое изменение реактивных свойств компонента запускает цикл обновления, в результате которого компонент рендерится заново.

Lit выполняет пакетное обновление для повышения производительности и эффективности. Установка нескольких свойств одновременно вызывает только одно обновление, выполняемое асинхронно с микрозадачей.

Во время обновления перерисовываются только те части DOM, которые изменяются. Хотя шаблоны Lit выглядят как интерполяция строк, Lit разбирает и создает статический HTML один раз, а затем только обновляет измененные значения в выражениях, что делает обновление очень эффективным.

Более подробную информацию о цикле обновления можно найти в разделе [Что происходит при изменении свойств](properties.md#when-properties-change).

## Инкапсуляция DOM

Lit использует теневой DOM для инкапсуляции DOM, отображаемого компонентом. Теневой DOM позволяет элементу создавать свое собственное, изолированное дерево DOM, отдельное от основного дерева документа. Это основная особенность спецификаций веб-компонентов, которая обеспечивает совместимость, инкапсуляцию стилей и другие преимущества.

Дополнительные сведения о теневом DOM см. в разделе [Shadow DOM v1: Self-Contained Web Components](https://developers.google.com/web/fundamentals/web-components/shadowdom) на сайте Web Fundamentals.

Дополнительные сведения о работе с теневым DOM в вашем компоненте см. в разделе [Работа с теневым DOM](shadow-dom.md).

## См. также

-   [Теневой DOM](shadow-dom.md)
-   [Обзор шаблонов](../templates/overview.md)
-   [Выражения шаблонов](../templates/expressions.md)
